#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <queue>
#include <unordered_map>
#include <algorithm>
#include <memory>

// 定义 Rank 为无符号整型
typedef unsigned int Rank;

// 位图类
class Bitmap {
private:
    std::unique_ptr<unsigned char[]> M; // 使用智能指针管理位图内存
    Rank N, _sz; // N为位图字节数，_sz为已设置的位数

    // 初始化函数
    void init(Rank n) {
        N = (n + 7) / 8; // 计算位图需要的字节数
        M = std::make_unique<unsigned char[]>(N);
        memset(M.get(), 0, N); // 初始化为0
        _sz = 0; // 设置已设置位数为0
    }

public:
    // 默认构造函数，位图大小为8
    Bitmap(Rank n = 8) { init(n); }
    
    // 从文件构造位图
    Bitmap(const char* file, Rank n = 8) {
        init(n);
        std::ifstream infile(file, std::ios::binary);
        infile.read(reinterpret_cast<char*>(M.get()), N);
        for (Rank k = 0; k < n; ++k) {
            _sz += test(k); // 统计设置的位数
        }
    }

    // 设置第k位为1
    void set(Rank k) {
        expand(k); // 扩展位图
        _sz++; // 更新已设置位数
        M[k >> 3] |= (0x80 >> (k & 0x07)); // 设置对应的位
    }
    
    // 清除第k位
    void clear(Rank k) {
        expand(k);
        _sz--; // 更新已设置位数
        M[k >> 3] &= ~(0x80 >> (k & 0x07)); // 清除位
    }
    
    // 检查第k位是否为1
    bool test(Rank k) const {
        expand(k);
        return M[k >> 3] & (0x80 >> (k & 0x07)); // 返回对应的位
    }
    
    // 将位图保存到文件
    void dump(const char* file) const {
        std::ofstream outfile(file, std::ios::binary);
        outfile.write(reinterpret_cast<const char*>(M.get()), N);
    }
    
    // 将位图转换为字符串
    char* bits2string(Rank n) {
        expand(n - 1);
        char* s = new char[n + 1];
        s[n] = '\0';
        for (Rank i = 0; i < n; ++i) {
            s[i] = test(i) ? '1' : '0'; // 设置每一位字符
        }
        return s; // 返回字符串
    }

    // 扩展位图
    void expand(Rank k) {
        if (k < 8 * N) return; // 如果k在范围内，不需要扩展
        Rank oldN = N;
        auto oldM = std::move(M);
        init(2 * k); // 初始化新大小
        std::memcpy(M.get(), oldM.get(), oldN); // 复制旧内容
    }
};

// 哈夫曼树节点结构体
struct HuffTreeNode {
    char data; // 字符
    int frequency; // 字符频率
    std::unique_ptr<HuffTreeNode> left; // 左子树指针
    std::unique_ptr<HuffTreeNode> right; // 右子树指针
    HuffTreeNode(char value, int freq) : data(value), frequency(freq) {}

    // 重载运算符用于优先队列比较
    bool operator>(const HuffTreeNode& other) const {
        return frequency > other.frequency; // 频率较小的节点优先
    }
};

// 哈夫曼树类
class HuffTree {
private:
    std::unique_ptr<HuffTreeNode> root; // 树根指针

public:
    HuffTree() : root(nullptr) {}

    // 根据文本构建哈夫曼树
    void buildTree(const std::string& text) {
        std::unordered_map<char, int> frequencyMap; // 字符频率映射
        for (char c : text) {
            if (isalpha(c)) {
                frequencyMap[tolower(c)]++; // 统计字母频率
            }
        }

        // 优先队列存储哈夫曼树节点
        std::priority_queue<std::unique_ptr<HuffTreeNode>, std::vector<std::unique_ptr<HuffTreeNode>>, std::greater<>> pq;
        for (const auto& pair : frequencyMap) {
            pq.push(std::make_unique<HuffTreeNode>(pair.first, pair.second)); // 入队
        }

        // 构建哈夫曼树
        while (pq.size() > 1) {
            auto left = std::move(pq.top());
            pq.pop();
            auto right = std::move(pq.top());
            pq.pop();
            auto newNode = std::make_unique<HuffTreeNode>('$', left->frequency + right->frequency);
            newNode->left = std::move(left);
            newNode->right = std::move(right);
            pq.push(std::move(newNode)); // 入队新节点
        }
        root = std::move(pq.top()); // 最终节点成为树根
    }

    // 生成哈夫曼编码
    void generateCodes(std::unordered_map<char, std::string>& codes, const HuffTreeNode* node, const std::string& code) {
        if (node == nullptr) return; // 递归终止条件
        if (node->left == nullptr && node->right == nullptr) { // 叶子节点
            codes[node->data] = code; // 存储编码
            return;
        }
        generateCodes(codes, node->left.get(), code + "0"); // 左子树编码
        generateCodes(codes, node->right.get(), code + "1"); // 右子树编码
    }
};

// 哈夫曼编码类
class HuffCode {
public:
    // 编码函数
    std::string encode(const std::string& text, const HuffTree& huffTree) {
        std::unordered_map<char, std::string> codes; // 存储字符与编码的映射
        huffTree.generateCodes(codes, huffTree.root.get(), ""); // 生成编码
        std::string encodedText; // 保存编码后的文本
        for (char c : text) {
            if (isalpha(c)) {
                encodedText += codes[tolower(c)]; // 转换为编码
            }
        }
        return encodedText; // 返回编码结果
    }
};

int main() {
    std::string text = "I have a dream"; // 测试文本
    HuffTree huffTree; // 创建哈夫曼树对象
    huffTree.buildTree(text); // 构建哈夫曼树
    HuffCode huffCode; // 创建哈夫曼编码对象
    std::string encodedText = huffCode.encode(text, huffTree); // 进行编码
    std::cout << "Encoded text: " << encodedText << std::endl; // 输出编码结果
    return 0; // 程序结束
}
